/**
 * 제네릭을 사용하는 이유
 *
 * 1. 중복되는 타입 코드의 문제점
 * - 아래와 같이 파라미터를 넘겨받아 해당 파라미터를 반환해주는 기능이 같은 함수가 있다면 해당 파라미터의 타입이 달라진다면
 *   타입마다 함수를 추가 해주어야한다.
 *   ex)
 *          function getText(text: string): string {
 *              return text;
 *          }
 *
 *          function getNumber(num: number): number {
 *              return num;
 *          }
 *
 *   => 같은 동작을 하는 코드를 중복해서 선언한 꼴이된다.
 *
 * 2. any사용의 지양
 * - 위 예제에서 any 타입을 사용하면 당장의 문제는 해결이 되지만 타입스크립트의 장점인 에러의 사전 방지나 코드 자동완성 기능은 사용할 수 없다.
 *
 * 3. 제네릭으로 해결되는 문제점
 * - 동일한 동작의 코드를 타입 때문에 중복으로 선언하는 문제점과 any타입으로 선언하면서 생기는 문제점을 제네릭으로 모두 해결할 수 있다.
 *   ex)
 *      function getText<T>(text: T): T {
 *          return text;
 *      }
 *
 *   => 위 코드는 getText() 함수에 제네릭을 선언하고 파라미터와 반환 타입에 제네릭 타입을 연결하는데
 *      getText<string>('hi') 와 같이 제네릭 타입을 지정하게 되면 text파라미터가 문자열로 추론되고 그에 따른 자동완성 기능도 사용할 수 있다.
 */
